function [pt_min, dist_min] = find_closest_point(position, path, segment)
% FIND_CLOSEST_POINT
%
% This function finds the point on the path that is closest to the current
% position of the robot.  Optionally, if the segment is specified, the
% function returns the point on the segment that is closest to the robot.
% For example, segment 3 consists of the line segment connecting points
% 3 and 4 in the path.
%
% INPUTS:
% position 	- 2 x 1, current position of the robot
% path 		- 2 x n, way points [x; y]
% segment   - 1 x 1, segment id [OPTIONAL], must be 1, 2, ..., n-1
%
% OUTPUTS:
% pt_min    - 2 x 1, point closest to the current robot position
% dist_min 	- 1 x 1, minimum distance from the robot to the path

% =================== Your code goes here ===================

% You should fill this in


%can we use segment as a linear index for path? then we can begin by
%creating some line with P1 and P2 (two points along path). We project the
%robot pose onto this line and see if its close to the projected point, or
%the two ends using an algorithim that determines closet point


%navigating path/waypts: point = waypts(:,segment) (all rows, but only the first
%column, etc. x = point(1) y = point(2)

%number of points that make up the line segment
n = 5

%base point of the line segment
if nargin == 3
    basept = path(:,segment);
    basex = basept(1);
    basey = basept(2);
    
    
    %head point of the line segment
    headpt = path(:,segment+1);
    headx = headpt(1);
    heady = headpt(2);
    
    
    %slope:
    slope = (heady - basey) / (headx - basex);

    %generate line:
    linepts =  [ linspace(basex,headx,n); linspace(basey,heady,n)]
    %need to test without using segment one, since that is the robot starting at origin and segment 2 is the point directly above origin? we need to generate a line from p2 to p3 not p1 to p2, p1 is origin of circle
  % returns q the closest point to p on the line segment from A to B 

  % vector from A to B
  AB = (B-A);
  % squared distance from A to B
  AB_squared = dot(AB,AB);
  if(AB_squared == 0)
    % A and B are the same point
    q = A;
  else
    % vector from A to p
    Ap = (p-A);
    % from http://stackoverflow.com/questions/849211/
    % Consider the line extending the segment, parameterized as A + t (B - A)
    % We find projection of point p onto the line. 
    % It falls where t = [(p-A) . (B-A)] / |B-A|^2
    t = dot(Ap,AB)/AB_squared;
    if (t < 0.0) 
      % "Before" A on the line, just return A
      q = A;
    else if (t > 1.0) 
      % "After" B on the line, just return B
      q = B;
    else
      % projection lines "inbetween" A and B on the line
      q = A + t * AB;
    end
  end
end
    
    %projection:
    


end







dist_min = Inf;
pt_min = [0; 0];

% =================== Your code ends here ===================

